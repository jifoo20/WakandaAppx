<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"   "http://www.w3.org/TR/html4/loose.dtd"><html lang="en"><head>	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">	<title>Wakanda Training - Web Workers</title>	<meta name="generator" content="TextMate http://macromates.com/">	<meta name="author" content="David Robbins">	<!-- Date: 2013-01-25 -->		<link rel="stylesheet" href="reveal/css/reveal.css">	<link rel="stylesheet" href="reveal/css/theme/wak.css" id="theme">	<!-- For syntax highlighting -->	<link rel="stylesheet" href="reveal/lib/css/zenburn.css">	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script></head><body><div id="container"><div class="reveal"><!-- Any section element inside of this container is displayed as a slide --><div class="slides spreadMore">	    <section>        <h2>Wakanda Intermediate Client-Side Training</h2>		<br/>        <p><strong>Web Workers</strong></p>        <br/><br/>				<p>Wakanda Server Web Workers Provide JavaScript Multithreading Capabilities.</p>		<br/><br/><br/>		<div class="fragment">		<p>There are two types of Web Workers: </p>				<ul>			<li>				<strong>Dedicated Workers</strong>				<p class="fragment">Dedicated workers have one "parent" and can only communicate with their parent or the workers they spawn.</p>			</li>				<li>				<strong>Shared Workers</strong>				<p class="fragment">Shared workers can be shared among several callers.</p>			</li>		</ul>		</div>	</section>	<section>        <h2>Web Workers</h2>		<br/><br/><br/><br/>		<div>			<p>The main difference between a dedicated worker and a shared worker is scope.</p>			<br/>			<p>A <strong>dedicated</strong> worker can only be addressed from the parent thread that created it.</p> 			<br/>			<p>A <strong>shared</strong> worker can be addressed from any thread. Dedicated workers terminate when the parent thread ends while shared workers continue to exist even if their spawning thread ends.</p>		</div>	</section>	<section>        <h2>Shared Worker</h2>		<br/>        <p>Shared Web Worker instances are created with the <strong>SharedWorker( )</strong> constructor method.</p>        <br/><br/>				<p>A Web worker is created by referencing an individual JavaScript file.</p>		<p>When the worker is instantiated, it then becomes an object residing in memory waiting to be called.</p>		<br/>		<p>When other threads want to interact with an already existing shared worker, they do so by executing the same code as if they are creating it.</p>		<p>But instead receive a reference to this existing shared worker.</p>		<br/><br/><pre><code>var newWorker = new SharedWorker("Workers/myDaemon.js", "myDaemon");</code></pre>	</section>	<section>        <h2>Sending a Message to a Shared Worker</h2>		<br/>        <p>The <strong>postMessage( )</strong> method allows you to exchange data between a parent Worker proxy and a shared Web worker.</p>        <br/>		<p>In the shared worker the <strong>onmessage()</strong> property contains the function that receives the message.</p>		<br/>				<br/>		<strong>Parent - Shared Worker Proxy</strong><br/>		<pre><code>var newWorker = new SharedWorker("Workers/myDaemon.js", "myDaemon");newWorker.postMessage({what: 'createLogRecord', title: "Upate name."});</code></pre>		<br/><br/>		<strong>Shared Worker</strong><br/>		<pre><code>function onconnect(msg) {   var thePort = msg.ports[0];   thePort.onmessage = function(messageEvt) {      switch(messageEvt.data.what) {         // Take action based on message.      }   }}</code></pre>		</section></div>	</div></div><!--left: 100%; margin-left: -120px;--><!--<div style="position: absolute; bottom: 20px;  background-color: black;"><img src="reveal/img/petitlogo.png"></div>--><script type="text/javascript" src="reveal/lib/js/head.min.js"></script><script type="text/javascript" src="reveal/js/reveal.js"></script><script type="text/javascript">var currentEntity;Reveal.initialize({	controls: true,	progress: true,	history: true,	center: true,	overview: true,	theme: Reveal.getQueryHash().theme, // available themes are in /css/theme	transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none	// Optional libraries used to extend on reveal.js	dependencies: [		{ src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },		{ src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },		{ src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },		{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },		{ src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },		{ src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }	//	{ src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }	]});Reveal.addEventListener( 'slidechanged', function( event ) {	//debugger;    // event.previousSlide, event.currentSlide, event.indexh, event.indexv	if (event.indexh == 2 && event.indexv == 1) {		currentEntity = $('#wakandaCollection ul').children('li.currentEntity');		console.log(currentEntity);		//$('#wakandaCollection ul').children('li.currentEntity').click(function() {console.log("currentEntity");});	}} );//</script></body></html>